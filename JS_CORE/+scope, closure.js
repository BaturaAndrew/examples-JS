// В JavaScript у каждой выполняемой функции, блока кода и скрипта есть
// связанный с ними внутренний(скрытый) объект, называемый лексическим окружением LexicalEnvironment.
// Лексическое окружение существует для любых блоков кода {...}.
// Для цикла у каждой итерации своё отдельное лексическое окружение.

// Объект лексического окружения состоит из двух частей:
// - Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также this).
// - Ссылка на внешнее лексическое окружение – то есть то, которое соответствует
// коду снаружи(снаружи от текущих фигурных скобок). Устанавливается в значение [[Environment]] функции.

// Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.
// Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое
// окружение места, где они были созданы.
// То есть, они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]]
// и все они могут получить доступ к внешним переменным.

// Где была создана, оттуда и получаешь переменные (не оттуда, где была вызвана)
let v = 1;
const f1 = function () {
  console.log(v);
};
const f2 = function () {
  v = 2; // изменили глобальную переменную
  // var v=3 // но в этом случае создастся локальная переменная, а в ф-ции f1 v ссылается на глобальную
  // поэтому результат вызова f2() будет 1
  f1();
};
f2(); // 2
// ___________________________________________

let name = 'John';

function sayHi() {
  console.log(`Hi, ${name}`);
}

name = 'Pete';
sayHi(); // Hi, Pete
// ___________________________________________

// Когда console.log внутри say хочет получить доступ к name, он немедленно находит переменную в лексическом
// окружении функции.
// Когда он хочет получить доступ к phrase, которой нет локально, он следует дальше и
// по ссылке на внешнее лексическое окружение находит переменную.

function say(name) {
  console.log(`${name}, ${phrase}`);
  console.log(someVarable);
}

let phrase = 'Привет';
const someVarable = 999;
say('Вася'); // Вася, Привет

// Внешнее лексическое окружение для function say() будет: say(): function
//  phrase: 'Привет'
//  someVarable: 999
// И ф-ция получает доступ ко всем переменным, к-е находятся во внешнем лексическом окружении

// Функция work в ссылку на внешнее лексическое окружение OUTER помещает лексическое окружение ф-ции makeWorker
// и так как в локальном лексическом окружении ф-ции work нет переменной name1, то она берется из OUTER ф-ции
// makeWorker (берется из локального окружения makeWorker, а уже в глобальном окружении этой ф-ции есть переменная
// name1 = "John")

function makeWorker() {
  const name1 = 'Pete';

  return function () {
    // это будет work
    console.log(name1);
  };
}

const name1 = 'John';
const work = makeWorker();
work(); // Pete
// ___________________________________________

// Пути создания IIFE

(function () {
  console.log('Скобки вокруг функции');
})();

(function () {
  console.log('Скобки вокруг всего');
})();

!(function () {
  console.log('Выражение начинается с побитового оператора NOT');
})();

+(function () {
  console.log('Выражение начинается с унарного плюса');
})();

// СБОРКА МУСОРА

function f() {
  const value = 123;
  function g() {
    alert(value);
  }
  return g;
}

let g = f(); // пока g существует,
// соответствующее лексическое окружение сохраняется

g = null; // ...а теперь память очищается
