// Методы apply и call позволяют задать контекст для выполняемой функции.

// Разница
function f(a, b, c) {
  return a * b + c;
}
// В обоих случаях вызовется функция f с аргументами a = 1, b = 2, c = 3;
var args = [1, 2, 3];
// console.log(f.call(null, 1, 2, 3)); // аргументы перечисляются через запятую;
// console.log(f.apply(null, args)); // // аргументы передаются в виде массива;


// example
var f = function () {
  this.x = 5;
  (function () {
    this.x = 3;
  })();
  console.log(this.x);
};

var obj = {
  x: 4,
  m: function () {
    console.log(this.x);
  }
};


// f(); // 3 // глобальному this привязывается поле x и записывается значение 5
//      // затем вызывается IIFE и перезаписывается this.x = 3 
// new f(); // 5 // создается объект со значением x = 5
// obj.m(); // 4
// new obj.m(); // undefined //  создается объект, но внутри данной функции не устанавливается значение для this.x
// f.call(null); // 3  // т.к. в качестве контекста не передается ничего, то this указывает на глобальный объект
// f.call(f); // 5  // первым параметром в call указана сама функция (точнее объект) f, поэтому
                    //  this ссылается на f, т.е. this.x = 5; // f.x = 5;
// obj.m.call(f); // 5  // поэтому this вновь ссылается на f
                     // в предыдущем примере f.x было присвоено значение 5, поэтому результат 5


let binded = f.bind(f);
binded(); // 5

binded.call(obj); // 5 // Сохраняется изначальная привязка к контексту, и 2-й раз уже не привязвается